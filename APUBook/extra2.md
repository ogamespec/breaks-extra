# Схема OAM DMA

![oam_dma_parts](/APUBook/imgstore/oam_dma_parts.png)

OAM DMA - это один из двух контроллеров DMA внутри APU.

## Сигналы

- ACLK и #ACLK: APU Clock
- PHI1: первая половина цикла CPU
- R/W: Сигнал R/W CPU (режим работы; 1: Read Mode, 0: Write Mode)
- RUNDMC: Сигнал блокировки OAM DMA со стороны DPCM DMA. Используется для приостановки OAM DMA при пересечении двух DMA
- SPRS: Сигнал разрешающий пересчёт счетчика OAM (младшие 8 бит адреса). Сигнал глушится RUNDMC
- SPRE: Сигнал переполнения счётчика OAM. Используется для определения завершения OAM DMA
- DMCReady: Сигнал готовности DPCM DMA. Комбинируется вместе с сигналом готовности OAM DMA для формирования сигнала RDY для 6502
- SPR_CPU: Произвести чтение байта в DMA Buffer по адресу OAM Counter. Сигнал глушится RUNDMC
- SPR_PPU: Произвести запись в регистр $2004 значение в DMA Buffer. Сигнал глушится RUNDMC

## Основные компоненты схемы

**RS-FF для хранения события записи в регистр $4014 (сигнал W4014)**

Данный RS-FF устанавливается когда активируется операция записи W4014. Сигнал W4014, как и остальные RegOps активен только во время PHI2 (вторая половина цикла CPU).
Очистка этого RS-FF происходит сигналом RES, а также сразу после начала OAM DMA (когда сигнал NOSPR становится равным 0).

**Детектор CPU Read Cycle**

Сделан просто: `read_cycle = (R_W == 1) & (PHI1 == 0)`
Необходимость детектора Read Cycle связана с тем, что процессор игнорирует низкий уровень сигнала RDY во время циклов чтения.

Событие начала OAM DMA считается наступившим, если:
- Произошло событие записи в регистр $4014
- Процессор перешёл в Read Cycle

**RS-FF "DMA Enabler"**

Защёлкивает событие начала OAM DMA (сигнал DOSPR). Очищается сигналом SPRE и во время сброса (RES).

**Защёлка "No Sprite DMA" (nospr_latch)**

Данная защёлка запоминает последнее значение DMA Enabler, но открывается только во время #ACLK. С открытием этой защёлки во время #ACLK как раз связан случай "невыровненного DMA": даже если все события начала OAM DMA были получены и сохранены на защёлке DMA Enabler - реально OAM DMA не начнётся, пока не наступит #ACLK.

**RS-FF DirToggle**

Обычный FF, который постоянно меняет своё значение с 0 на 1 и обратно, таким образом определяет направление OAM DMA.

**Формирователь RDY**

Сигнал RDY для процессора это просто логическое-И сигналов oamdma_rdy и DMCReady.

## Процесс DMA

Сигнал NOSPR является основной движущей силой всего OAM DMA. Когда NOSPR равен 0 - схема OAM DMA производит свою деятельность по обеспечения процесса OAM DMA.

Процесс OAM DMA заключает в себе следующие действия:
- Попеременная смена направления DMA (DMA DirToggle), которая в итоге формирует сигналы SPR_PPU и SPR_CPU
- Активирование сигнала SPRS для включения счётчика OAM Counter (чтобы адрес OAM DMA постоянно увеличивался)

Данные процессы "глушатся" сигналом RUNDMC.

Процесс начала OAM DMA:
![oam_dma_start](/APUBook/imgstore/oam_dma_start.png)

Завершение OAM DMA:
![oam_dma_last](/APUBook/imgstore/oam_dma_last.png)

## Взаимодействие DPCM DMA и OAM DMA

DPCM DMA влияет на работу OAM DMA всего двумя способами:
- Сигнал RUNDMC "заглушает" (обнуляет) сигнал пересчёта OAM Counter (SPRS) и сигналы для направления OAM DMA (SPR_CPU/SPR_PPU). Таким образом реально приостанавливается только OAM Counter. DirToggle продолжает работать, поэтому нужно соблюдать точный тайминг сигнала RUNDMC, чтобы на момент "отжатия" RUNDMC - DirToggle принял такое же значение, что и раньше
- Сигнал DMCReady просто "пробрасывается" на терминал RDY процессора. Естественно, если сигнал oamdma_rdy равен 0, то сигнал DMCReady не имеет эффекта. Такое может быть например при завершении DPCM DMA "внутри" OAM DMA: DPCM DMA скажет DMCReady=1, но процессор всё равно не разбудится, т.к. сигнал oamdma_rdy всё ещё равен 0 (OAM DMA не завершилась)
